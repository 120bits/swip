<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Swip</title>
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <style>
      html, body {
        margin: 0;
        padding: 0;
      }
    </style>
  </head>

  <body>

    <canvas id="canvas"></canvas>

    <script src="/socket.io/socket.io.js"></script>
    <script src="/swip/swip.js"></script>
    <script>
      var socket = io.connect();

      var client = {};
      var walls = {
        left: [ {start: 0, end: window.innerHeight} ],
        top: [ {start: 0, end: window.innerWidth} ],
        right: [ {start: 0, end: window.innerHeight} ],
        bottom: [ {start: 0, end: window.innerWidth} ],
      };

      var canvas = document.getElementById('canvas');
      var ctx = canvas.getContext("2d");

      canvas.setAttribute('width', window.innerWidth);
      canvas.setAttribute('height', window.innerHeight);

      ctx.fillStyle = 'black';
      ctx.fillRect(0,0, canvas.width, canvas.height);

      drawWalls(ctx);

      function getRandomColor () {
        var letters = '0123456789ABCDEF'.split('');
        var color = '#';
        for (var i = 0; i < 6; i++ ) {
          color += letters[Math.floor(Math.random() * 16)];
        }
        return color;
      }

      function drawWalls (ctx) {
        ctx.strokeStyle = "red";
        ctx.lineWidth = 50;

        walls.left.forEach(function (wall) {
          ctx.beginPath();
          ctx.moveTo(0, wall.start);
          ctx.lineTo(0, wall.end);
          ctx.stroke();
        });

        walls.top.forEach(function (wall) {
          ctx.beginPath();
          ctx.moveTo(wall.start, 0);
          ctx.lineTo(wall.end, 0);
          ctx.stroke();
        });

        walls.right.forEach(function (wall) {
          ctx.beginPath();
          ctx.moveTo(window.innerWidth, wall.start);
          ctx.lineTo(window.innerWidth, wall.end);
          ctx.stroke();
        });

        walls.bottom.forEach(function (wall) {
          ctx.beginPath();
          ctx.moveTo(wall.start, window.innerHeight);
          ctx.lineTo(wall.end, window.innerHeight);
          ctx.stroke();
        });
      }

      function getAlignment (device1, device2) {
          if (device2.transform.x >= (device1.transform.x + device1.size.width)) {
            return "LEFT";
          } else if (device1.transform.x >= (device2.transform.x + device2.size.width)) {
            return "RIGHT";
          } else if (device2.transform.y >= (device1.transform.y + device1.size.height)) {
            return "TOP";
          } else if (device1.transform.y >= (device2.transform.y + device2.size.height)) {
            return "BOTTOM";
          }
      }

      function getDevices (deviceIDs, devices) {
        return deviceIDs.map(function (deviceID) {
          return devices.filter(function (device) {
            return device.id === deviceID;
          })[0];
        });
      }

      swip.device.requestSize(function (converter) {

        socket.emit('CONNECT_CLIENT', {
          size: {
            width: converter.toAbsPixel(window.innerWidth),
            height: converter.toAbsPixel(window.innerHeight),
          }
        });

        swip.sensor.onSwipe(window, function (evt) {
          socket.emit('SWIPE', { direction: evt.direction, position: { x: converter.toAbsPixel(evt.position.x), y: converter.toAbsPixel(evt.position.y) }});
        });

        /*swip.sensor.onMotion(function () {
          socket.emit('LEAVE_CLUSTER');
        });*/

        canvas.addEventListener('click', function (evt) {

          var particles = [];
          for(var i = 0; i < 200; i++) {
            particles.push({
              x: converter.toAbsPixel(evt.clientX) + (client.transform ? client.transform.x : 0),
              y: converter.toAbsPixel(evt.clientY) + (client.transform ? client.transform.y : 0),
              speedX: Math.random() * 20 -10,
              speedY: Math.random() * 20 -10,
              color: getRandomColor(),
              ttl: 250,
            });
          }
            socket.emit("CLIENT_ACTION", {
              type: 'addParticle',
              data: particles
            });
        });

        socket.on('CHANGED', function (evt) {

          if (evt.cluster) {

            ctx.fillRect(0,0, canvas.width, canvas.height);

            var connectedDevices = getDevices(evt.client.connections, evt.cluster.clients);

            walls = {
              left: [],
              top: [],
              right: [],
              bottom: [],
            };

            connectedDevices.forEach(function (device) {
              var alignment = getAlignment(evt.client, device);

              switch (alignment) {
                case 'LEFT':
                  console.log("Left");
                  if (evt.client.transform.y < device.transform.y && evt.client.size.height > device.size.height + (Math.abs(device.transform.y - evt.client.transform.y))) {
                    walls.right.push( {
                      start: converter.toDevicePixel(Math.abs(evt.client.transform.y - device.transform.y)),
                      end: converter.toDevicePixel(Math.abs(evt.client.transform.y - device.transform.y) + device.size.height),
                    });

                  } else if(evt.client.transform.y > device.transform.y) {
                    walls.right.push( {
                      start: 0,
                      end: converter.toDevicePixel(device.size.height - (Math.abs(evt.client.transform.y - device.transform.y))),
                    });
                  } else {
                    walls.right.push( {
                      start: converter.toDevicePixel(Math.abs(evt.client.transform.y - device.transform.y)),
                      end: converter.toDevicePixel(evt.client.size.height),
                    });
                  }
                  break;

                case 'RIGHT':
                  console.log("Right");
                  if (evt.client.transform.y < device.transform.y && evt.client.size.height > device.size.height + (Math.abs(device.transform.y - evt.client.transform.y))) {
                    walls.left.push( {
                      start: converter.toDevicePixel(Math.abs(evt.client.transform.y - device.transform.y)),
                      end: converter.toDevicePixel(Math.abs(evt.client.transform.y - device.transform.y) + device.size.height),
                    });

                  } else if(evt.client.transform.y > device.transform.y) {
                    walls.left.push( {
                      start: 0,
                      end: converter.toDevicePixel(device.size.height - (Math.abs(evt.client.transform.y - device.transform.y))),
                    });
                  } else {
                    walls.left.push( {
                      start: converter.toDevicePixel(Math.abs(evt.client.transform.y - device.transform.y)),
                      end: converter.toDevicePixel(evt.client.size.height),
                    });
                  }
                  break;

                case 'TOP':
                  console.log("Top");
                  if (evt.client.transform.x < device.transform.x && evt.client.size.width > device.size.width + Math.abs(evt.client.transform.x - device.transform.x)) {
                    walls.bottom.push( {
                      start: converter.toDevicePixel(Math.abs(evt.client.transform.x - device.transform.x)),
                      end: converter.toDevicePixel(device.size.width + Math.abs(evt.client.transform.x - device.transform.x)),
                    });
                  } else if(evt.client.transform.x > device.transform.x) {
                    walls.bottom.push( {
                      start: 0,
                      end: converter.toDevicePixel(device.size.width - Math.abs(evt.client.transform.x - device.transform.x)),
                    });
                  } else {
                    walls.bottom.push( {
                      start: converter.toDevicePixel(Math.abs(evt.client.transform.x - device.transform.x)),
                      end: converter.toDevicePixel(evt.client.size.width),
                    });
                  }
                  break;

                case 'BOTTOM':
                  console.log("Bottom");
                  if (evt.client.transform.x < device.transform.x && evt.client.size.width > device.size.width + Math.abs(evt.client.transform.x - device.transform.x)) {
                    walls.top.push( {
                      start: converter.toDevicePixel(Math.abs(evt.client.transform.x - device.transform.x)),
                      end: converter.toDevicePixel(device.size.width + Math.abs(evt.client.transform.x - device.transform.x)),
                    });
                  } else if(evt.client.transform.x > device.transform.x) {
                    walls.top.push( {
                      start: 0,
                      end: converter.toDevicePixel(device.size.width - Math.abs(evt.client.transform.x - device.transform.x)),
                    });
                  } else {
                    walls.top.push( {
                      start: converter.toDevicePixel(Math.abs(evt.client.transform.x - device.transform.x)),
                      end: converter.toDevicePixel(evt.client.size.width),
                    });
                  }
                  break;

                default:
                  console.log("WTF");
                  break;
              }
            });

            drawWalls(ctx);
            
            ctx.save();
            ctx.translate(-converter.toDevicePixel(evt.client.transform.x), -converter.toDevicePixel(evt.client.transform.y));

            client = evt.client;

            var particles = evt.cluster.data.particles;

            particles.forEach(function (particle) {
              ctx.fillStyle = particle.color;
              ctx.fillRect(
                converter.toDevicePixel(particle.x),
                converter.toDevicePixel(particle.y),
                converter.toDevicePixel(10),
                converter.toDevicePixel(10)
              );
            });

            ctx.restore();
          }
        })
      });

    </script>
  </body>
</html>





