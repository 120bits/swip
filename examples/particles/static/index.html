<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Swip</title>
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <style>
      html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
      }
    </style>
  </head>

  <body>

    <div id="root"></div>

    <script src="/socket.io/socket.io.js"></script>
    <script src="/swip/swip.js"></script>
    <script>
      (function () {
        'use strict';

        var socket = io.connect();

        swip.init({
          socket: socket,
          container: document.getElementById('root'),
          type: 'canvas',
        }, function (client) {
          var converter = client.converter;
          var stage = client.stage;
          var ctx = stage.getContext('2d');

          var blobs = [];
          var activeBlobs = [];
          var blobsClicked = [];

          client.onDragStart(function (evt) {
            evt.position.forEach(function (pos) {
              for (var i = 0; i < blobs.length; i++) {
                if (touchInRadius(pos.x, pos.y, blobs[i].x, blobs[i].y, blobs[i].size)) {
                  blobsClicked.push({blob: blobs[i], xStart: pos.x, yStart: pos.y});
                }
              }
            });

            if (blobsClicked == false) {
              evt.position.forEach(function (pos) {
                activeBlobs.push({
                  x: pos.x,
                  y: pos.y,
                  speedX: 0,
                  speedY: 0,
                  size: converter.toAbsPixel(15)
                });
              });
            }
          });

          client.onDragMove(function (evt) {
            if (blobsClicked == false) {
              evt.position.forEach(function (pos) {
                for (var i = 0; i < activeBlobs.length; i++) {
                  if (touchInRadius(pos.x, pos.y, activeBlobs[i].x, activeBlobs[i].y, activeBlobs[i].size)) {
                    activeBlobs.splice(i, 1);
                    i--;
                  }
                }
              });
            } else {
              evt.position.forEach(function (pos) {
                for (var i = 0; i < blobs.length; i++) {
                  if (touchInRadius(pos.x, pos.y, blobs[i].x, blobs[i].y, blobs[i].size)) {
                    blobs[i].x = pos.x;
                    blobs[i].y = pos.y;
                  }
                }
                client.emit('updateBlobs', { blobs: blobs })
              });
            }
          });

          client.onDragEnd(function (evt) {
            if (blobsClicked == false) {
              evt.position.forEach(function (pos) {
                var emitBlobs = [];
                for (var i = 0; i < activeBlobs.length; i++) {
                  if (touchInRadius(pos.x, pos.y, activeBlobs[i].x, activeBlobs[i].y, activeBlobs[i].size)) {
                    emitBlobs.push(activeBlobs[i]);
                    activeBlobs.splice(i, 1);
                    i--;
                  }
                }
                if (emitBlobs) {
                  client.emit('addBlobs', { blobs: emitBlobs });
                }
              });
            } else {
              blobsClicked = [];
            }
          });

          client.onUpdate(function (evt) {

            if (evt.cluster) {
              var updatedBlobs = evt.cluster.data.blobs;
              blobs = updatedBlobs;

              ctx.fillStyle = evt.cluster.data.backgroundColor;
              ctx.fillRect(0, 0, stage.width, stage.height);

              ctx.save();
              ctx.translate(-converter.toDevicePixel(evt.client.transform.x), -converter.toDevicePixel(evt.client.transform.y));
              ctx.scale(converter.toDevicePixel(1), converter.toDevicePixel(1));

              drawOpenings(ctx, evt.client);

              ctx.shadowBlur = 0;

              if (activeBlobs) {
                for(var i = 0; i < activeBlobs.length; i++) {
                  activeBlobs[i].size += 1;
                }
              }

              activeBlobs.forEach(function(blob) {
                ctx.beginPath();
                ctx.arc(blob.x, blob.y, blob.size , 0, 2 * Math.PI, false);
                ctx.fillStyle = '#FFFFFF';
                ctx.fill();
              });

              updatedBlobs.forEach(function (blob) {
                ctx.beginPath();
                ctx.arc(blob.x, blob.y, blob.size , 0, 2 * Math.PI, false);
                ctx.fillStyle = '#FFFFFF';
                ctx.fill();
              });

              ctx.restore();
            }
          });
        });

        function touchInRadius (posX, posY, blobX, blobY, blobsSize) {
          var inRadius = false;
          blobsSize *= 2;

          if ((posX < (blobX + blobsSize) && posX > (blobX - blobsSize)) &&
            (posY < (blobY + blobsSize) && posY > (blobY - blobsSize))) {
            inRadius = true;
          }

          return inRadius;
        }

        function drawOpenings (ctx, client) {
          var openings = client.openings;
          var transformX = client.transform.x;
          var transformY = client.transform.y;
          var width = client.size.width;
          var height = client.size.height;

          ctx.lineWidth = 5;
          ctx.shadowBlur = 5;

          openings.left.forEach(function (wall) {
            ctx.strokeStyle = "#ff9e00";
            ctx.shadowColor = "#ff9e00";

            ctx.beginPath();
            ctx.moveTo(transformX, wall.start + transformY);
            ctx.lineTo(transformX, wall.end + transformY);
            ctx.stroke();
          });

          openings.top.forEach(function (wall) {
            ctx.strokeStyle = "#0084FF";
            ctx.shadowColor = "#0084FF";

            ctx.beginPath();
            ctx.moveTo(wall.start + transformX, transformY);
            ctx.lineTo(wall.end + transformX, transformY);
            ctx.stroke();
          });

          openings.right.forEach(function (wall) {
            ctx.strokeStyle = "#0084FF";
            ctx.shadowColor = "#0084FF";

            ctx.beginPath();
            ctx.moveTo(width + transformX, wall.start + transformY);
            ctx.lineTo(width + transformX, wall.end + transformY);
            ctx.stroke();
          });

          openings.bottom.forEach(function (wall) {
            ctx.strokeStyle = "#ff9e00";
            ctx.shadowColor = "#ff9e00";

            ctx.beginPath();
            ctx.moveTo(wall.start + transformX, height + transformY);
            ctx.lineTo(wall.end + transformX, height + transformY);
            ctx.stroke();
          });
        }
      }());
    </script>
  </body>
</html>





